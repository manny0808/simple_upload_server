const express = require('express');
const session = require('express-session');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
const db = require('./database');

const app = express();
const PORT = process.env.PORT || 8080;
const UPLOAD_BASE_DIR = process.env.UPLOAD_DIR || path.join(__dirname, 'uploads');
const MAX_FILE_SIZE_MB = parseInt(process.env.MAX_FILE_SIZE_MB) || 100;
const MAX_FILES_PER_UPLOAD = parseInt(process.env.MAX_FILES_PER_UPLOAD) || 10;
const AUTH_TOKEN = process.env.AUTH_TOKEN; // Bearer token for API auth
const REQUIRE_AUTH_FOR_DOWNLOAD = process.env.REQUIRE_AUTH_FOR_DOWNLOAD !== 'false';
const ENABLE_DELETE = process.env.ENABLE_DELETE !== 'false';

// Parse allowed extensions from ENV
const ALLOWED_EXTENSIONS = process.env.ALLOWED_EXTENSIONS 
    ? process.env.ALLOWED_EXTENSIONS.split(',').map(ext => ext.trim().toLowerCase())
    : null;

// Ensure base upload directory exists
if (!fs.existsSync(UPLOAD_BASE_DIR)) {
    fs.mkdirSync(UPLOAD_BASE_DIR, { recursive: true });
}

// Get user's upload directory
function getUserUploadDir(userId, userFolder) {
    if (!userFolder) {
        return path.join(UPLOAD_BASE_DIR, `user_${userId}`);
    }
    return path.join(UPLOAD_BASE_DIR, userFolder);
}

// Generate UUID for file ID
function generateUUID() {
    return crypto.randomUUID();
}

// Get file extension from filename
function getFileExtension(filename) {
    return path.extname(filename).toLowerCase();
}

// Generate stored filename: original name with conflict resolution
function generateStoredFilename(originalName, directory) {
    const ext = getFileExtension(originalName);
    const baseName = originalName.substring(0, originalName.length - ext.length);
    
    // Check if file already exists in directory
    let finalName = originalName;
    let counter = 1;
    
    while (fs.existsSync(path.join(directory, finalName))) {
        finalName = `${baseName} (${counter})${ext}`;
        counter++;
    }
    
    return finalName;
}

// Validate bucket name (a-zA-Z0-9-_)
function isValidBucket(bucket) {
    return /^[a-zA-Z0-9_-]+$/.test(bucket);
}

// Validate file extension against whitelist
function isValidExtension(filename) {
    if (!ALLOWED_EXTENSIONS) return true; // No whitelist = all allowed
    
    const ext = getFileExtension(filename).substring(1); // Remove dot
    return ALLOWED_EXTENSIONS.includes(ext);
}

// Calculate SHA256 hash of file
function calculateSHA256(filePath) {
    return new Promise((resolve, reject) => {
        const hash = crypto.createHash('sha256');
        const stream = fs.createReadStream(filePath);
        
        stream.on('data', data => hash.update(data));
        stream.on('end', () => resolve(hash.digest('hex')));
        stream.on('error', reject);
    });
}

// Format file size helper
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Bearer token authentication middleware
function requireBearerToken(req, res, next) {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    
    const token = authHeader.substring(7);
    
    if (token !== AUTH_TOKEN) {
        return res.status(403).json({ error: 'Invalid token' });
    }
    
    next();
}

// Combined auth: either session OR bearer token
function requireAuthCombined(req, res, next) {
    // Check session auth first
    if (req.session.userId) {
        return next();
    }
    
    // Check bearer token
    if (AUTH_TOKEN) {
        const authHeader = req.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            const token = authHeader.substring(7);
            if (token === AUTH_TOKEN) {
                return next();
            }
        }
    }
    
    // No valid auth found
    if (req.path.startsWith('/api/') || req.path.startsWith('/files/')) {
        return res.status(401).json({ error: 'Authentication required' });
    } else {
        res.redirect('/login');
    }
}

// Session middleware
app.use(session({
    secret: process.env.SESSION_SECRET || 'upload-server-secret-fixed-2024',
    resave: false,
    saveUninitialized: false,
    cookie: { 
        secure: false,
        maxAge: 24 * 60 * 60 * 1000 // 24 hours
    }
}));

// Configure multer for file uploads
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        // Temporary directory for uploads before validation
        const tempDir = path.join(__dirname, 'temp');
        if (!fs.existsSync(tempDir)) {
            fs.mkdirSync(tempDir, { recursive: true });
        }
        cb(null, tempDir);
    },
    filename: (req, file, cb) => {
        // Store with original name temporarily
        cb(null, file.originalname);
    }
});

const upload = multer({
    storage: storage,
    limits: {
        fileSize: MAX_FILE_SIZE_MB * 1024 * 1024,
        files: MAX_FILES_PER_UPLOAD
    },
    fileFilter: (req, file, cb) => {
        // Check file extension against whitelist
        if (!isValidExtension(file.originalname)) {
            return cb(new Error(`File type not allowed: ${file.originalname}`));
        }
        cb(null, true);
    }
});

// Body parsers
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Check if user is logged in
function requireAuth(req, res, next) {
    if (req.session.userId) {
        next();
    } else {
        res.redirect('/login');
    }
}

// Check if user is admin
function requireAdmin(req, res, next) {
    if (req.session.role === 'admin') {
        next();
    } else {
        res.status(403).send('Access denied. Admin only.');
    }
}

// Configure multer for file uploads (existing routes)
const userStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        const userDir = getUserUploadDir(req.session.userId, req.session.userFolder);
        if (!fs.existsSync(userDir)) {
            fs.mkdirSync(userDir, { recursive: true });
        }
        cb(null, userDir);
    },
    filename: (req, file, cb) => {
        cb(null, file.originalname);
    }
});

const userUpload = multer({ 
    storage: userStorage,
    limits: { fileSize: 100 * 1024 * 1024 }
});

// ========== LOGIN/LOGOUT ROUTES ==========

// Login page
app.get('/login', (req, res) => {
    res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

// Login POST
app.post('/login', (req, res) => {
    const { username, password } = req.body;
    
    db.verifyPassword(username, password, (err, user) => {
        if (err || !user) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        req.session.userId = user.id;
        req.session.username = user.username;
        req.session.role = user.role;
        req.session.userFolder = user.user_folder;
        
        // Create user directory if it doesn't exist
        const userDir = getUserUploadDir(user.id, user.user_folder);
        if (!fs.existsSync(userDir)) {
            fs.mkdirSync(userDir, { recursive: true });
        }
        
        res.json({ success: true, role: user.role });
    });
});

// Logout
app.get('/logout', (req, res) => {
    req.session.destroy();
    res.redirect('/login');
});

// ========== ADMIN ROUTES ==========

// Admin panel
app.get('/admin', requireAuth, requireAdmin, (req, res) => {
    res.sendFile(path.join(__dirname, 'views', 'admin.html'));
});

// Change password page
app.get('/change-password', requireAuth, (req, res) => {
    res.sendFile(path.join(__dirname, 'views', 'change-password.html'));
});

// Get all users (API)
app.get('/api/users', requireAuth, requireAdmin, (req, res) => {
    db.getAllUsers((err, users) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(users);
    });
});

// Create user
app.post('/api/users', requireAuth, requireAdmin, (req, res) => {
    const { username, password, role, storage_quota_mb = 100 } = req.body;
    
    db.createUser(username, password, role, storage_quota_mb, (err, user) => {
        if (err) return res.status(400).json({ error: err.message });
        res.json({ success: true, user });
    });
});

// Delete user
app.delete('/api/users/:id', requireAuth, requireAdmin, (req, res) => {
    const id = parseInt(req.params.id);
    
    // Prevent deleting yourself
    if (id === req.session.userId) {
        return res.status(400).json({ error: 'Cannot delete yourself' });
    }
    
    db.deleteUser(id, (err) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// Update user password
app.put('/api/users/:id/password', requireAuth, requireAdmin, (req, res) => {
    const id = parseInt(req.params.id);
    const { password } = req.body;
    
    db.updatePassword(id, password, (err) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// File upload endpoint
app.post('/api/upload', requireAuth, userUpload.array('file', 10), (req, res) => {
    const userId = req.session.userId;
    const username = req.session.username;
    
    // Get user info for quota check
    db.getUserById(userId, (err, user) => {
        if (err || !user) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        const userDir = getUserUploadDir(user.id, user.user_folder);
        const quotaBytes = user.storage_quota_mb * 1024 * 1024;
        
        // Calculate current usage
        let currentUsage = 0;
        if (fs.existsSync(userDir)) {
            const files = fs.readdirSync(userDir);
            files.forEach(file => {
                const filePath = path.join(userDir, file);
                const stats = fs.statSync(filePath);
                currentUsage += stats.size;
            });
        }
        
        // Calculate total size of new files
        let totalNewSize = 0;
        if (req.files && req.files.length > 0) {
            req.files.forEach(file => {
                totalNewSize += file.size;
            });
        }
        
        // Check quota
        if (currentUsage + totalNewSize > quotaBytes) {
            // Delete uploaded files if quota exceeded
            if (req.files && req.files.length > 0) {
                req.files.forEach(file => {
                    fs.unlinkSync(file.path);
                });
            }
            const available = quotaBytes - currentUsage;
            return res.status(400).json({ 
                error: `Quota exceeded. You have ${formatFileSize(available)} available, need ${formatFileSize(totalNewSize)}` 
            });
        }
        
        // Move files to user directory
        const uploadedFiles = [];
        if (req.files && req.files.length > 0) {
            req.files.forEach(file => {
                const newPath = path.join(userDir, file.originalname);
                fs.renameSync(file.path, newPath);
                uploadedFiles.push({
                    originalname: file.originalname,
                    filename: file.originalname,
                    size: file.size
                });
            });
        }
        
        // Calculate new usage
        const newUsage = currentUsage + totalNewSize;
        const usagePercentage = quotaBytes > 0 ? Math.min(100, (newUsage / quotaBytes) * 100) : 0;
        
        res.json({
            success: true,
            files: uploadedFiles,
            total_size: totalNewSize,
            file_count: uploadedFiles.length,
            storage_used: newUsage,
            storage_quota: quotaBytes,
            usage_percentage: usagePercentage
        });
    });
});

// Update user quota
app.put('/api/users/:id/quota', requireAuth, requireAdmin, (req, res) => {
    const id = parseInt(req.params.id);
    const { storage_quota_mb } = req.body;
    
    if (!storage_quota_mb || storage_quota_mb < 1) {
        return res.status(400).json({ error: 'Valid quota required (min 1MB)' });
    }
    
    db.updateUserQuota(id, storage_quota_mb, (err) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// ========== FILE MANAGEMENT ROUTES ==========

// Main app (requires login)
app.get('/', requireAuth, (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Upload UI (requires login)
app.get('/upload-ui', requireAuth, (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'upload-ui.html'));
});

// Get current user info
app.get('/api/me', requireAuth, (req, res) => {
    res.json({
        username: req.session.username,
        role: req.session.role,
        userId: req.session.userId
    });
});

// Change own password
app.post('/api/change-password', requireAuth, (req, res) => {
    const { currentPassword, newPassword } = req.body;
    
    if (!currentPassword || !newPassword) {
        return res.status(400).json({ error: 'Current and new password required' });
    }
    
    // Verify current password
    db.verifyPassword(req.session.username, currentPassword, (err, user) => {
        if (err || !user) {
            return res.status(401).json({ error: 'Current password is incorrect' });
        }
        
        // Update password
        db.updatePassword(req.session.userId, newPassword, (err) => {
            if (err) return res.status(500).json({ error: 'Failed to update password' });
            res.json({ success: true });
        });
    });
});

// Get files for current user
app.get('/api/files', requireAuth, (req, res) => {
    const userDir = getUserUploadDir(req.session.userId, req.session.userFolder);
    
    if (!fs.existsSync(userDir)) {
        return res.json([]);
    }
    
    fs.readdir(userDir, (err, files) => {
        if (err) return res.status(500).json({ error: 'Failed to read directory' });
        
        const fileList = files.map(file => {
            const filePath = path.join(userDir, file);
            const stats = fs.statSync(filePath);
            return {
                name: file,
                size: stats.size,
                sizeFormatted: formatFileSize(stats.size),
                modified: stats.mtime,
                url: `/download/${file}`
            };
        }).sort((a, b) => b.modified - a.modified);
        
        res.json(fileList);
    });
});

// Get user storage usage
app.get('/api/users/:id/usage', requireAuth, requireAdmin, (req, res) => {
    const id = parseInt(req.params.id);
    
    // Get user info first
    db.getUserById(id, (err, user) => {
        if (err || !user) return res.status(404).json({ error: 'User not found' });
        
        const userDir = getUserUploadDir(user.id, user.user_folder);
        let totalSize = 0;
        
        if (fs.existsSync(userDir)) {
            const files = fs.readdirSync(userDir);
            files.forEach(file => {
                const filePath = path.join(userDir, file);
                const stats = fs.statSync(filePath);
                totalSize += stats.size;
            });
        }
        
        res.json({
            user_id: user.id,
            username: user.username,
            storage_used_bytes: totalSize,
            storage_used_formatted: formatFileSize(totalSize),
            storage_quota_bytes: user.storage_quota_mb * 1024 * 1024,
            storage_quota_formatted: `${user.storage_quota_mb} MB`,
            usage_percentage: user.storage_quota_mb > 0 ? 
                Math.min(100, (totalSize / (user.storage_quota_mb * 1024 * 1024)) * 100) : 0
        });
    });
});

// Get current user storage usage (for user dashboard)
app.get('/api/me/usage', requireAuth, (req, res) => {
    const userId = req.session.userId;
    
    // Get user info first
    db.getUserById(userId, (err, user) => {
        if (err || !user) return res.status(404).json({ error: 'User not found' });
        
        const userDir = getUserUploadDir(user.id, user.user_folder);
        let totalSize = 0;
        
        if (fs.existsSync(userDir)) {
            const files = fs.readdirSync(userDir);
            files.forEach(file => {
                const filePath = path.join(userDir, file);
                const stats = fs.statSync(filePath);
                totalSize += stats.size;
            });
        }
        
        res.json({
            user_id: user.id,
            username: user.username,
            storage_used_bytes: totalSize,
            storage_used_formatted: formatFileSize(totalSize),
            storage_quota_bytes: user.storage_quota_mb * 1024 * 1024,
            storage_quota_formatted: `${user.storage_quota_mb} MB`,
            usage_percentage: user.storage_quota_mb > 0 ? 
                Math.min(100, (totalSize / (user.storage_quota_mb * 1024 * 1024)) * 100) : 0
        });
    });
});

// Get user storage usage (for admin)
app.get('/api/users/:id/usage', requireAuth, requireAdmin, (req, res) => {
    const id = parseInt(req.params.id);
    
    // Get user info first
    db.getUserById(id, (err, user) => {
        if (err || !user) return res.status(404).json({ error: 'User not found' });
        
        const userDir = getUserUploadDir(user.id, user.user_folder);
        let totalSize = 0;
        
        if (fs.existsSync(userDir)) {
            const files = fs.readdirSync(userDir);
            files.forEach(file => {
                const filePath = path.join(userDir, file);
                const stats = fs.statSync(filePath);
                totalSize += stats.size;
            });
        }
        
        res.json({
            user_id: user.id,
            username: user.username,
            storage_used_bytes: totalSize,
            storage_used_formatted: formatFileSize(totalSize),
            storage_quota_bytes: user.storage_quota_mb * 1024 * 1024,
            storage_quota_formatted: `${user.storage_quota_mb} MB`,
            usage_percentage: user.storage_quota_mb > 0 ? 
                Math.min(100, (totalSize / (user.storage_quota_mb * 1024 * 1024)) * 100) : 0
        });
    });
});

// Helper function to format file size
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Download file
app.get('/download/:filename', requireAuth, (req, res) => {
    const userDir = getUserUploadDir(req.session.userId, req.session.userFolder);
    const filePath = path.join(userDir, req.params.filename);
    if (!fs.existsSync(filePath)) {
        return res.status(404).send('File not found');
    }
    res.download(filePath);
});

// Delete file
app.delete('/api/files/:filename', requireAuth, (req, res) => {
    const userDir = getUserUploadDir(req.session.userId, req.session.userFolder);
    const filePath = path.join(userDir, req.params.filename);
    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
    }
    
    fs.unlink(filePath, (err) => {
        if (err) return res.status(500).json({ error: 'Failed to delete file' });
        res.json({ success: true });
    });
});

// ===== PROJECT REQUIREMENT ENDPOINTS =====

// Health endpoint (GET /health)
app.get('/health', (req, res) => {
    res.json({ 
        status: 'ok',
        timestamp: new Date().toISOString(),
        service: 'upload-server',
        version: '1.0.0'
    });
});

// Upload endpoint (POST /upload) - Project requirement
app.post('/upload', requireAuthCombined, upload.array('files', MAX_FILES_PER_UPLOAD), async (req, res) => {
    try {
        if (!req.files || req.files.length === 0) {
            return res.status(400).json({ error: 'No files uploaded' });
        }
        
        const bucket = req.body.bucket || 'default';
        
        // Validate bucket name
        if (!isValidBucket(bucket)) {
            // Clean up uploaded files
            req.files.forEach(file => fs.unlinkSync(file.path));
            return res.status(400).json({ error: 'Invalid bucket name. Use only a-zA-Z0-9-_' });
        }
        
        // Get user ID from session (if available)
        const userId = req.session.userId || null;
        const uploaderIp = req.ip;
        
        // Determine upload directory based on auth type
        let uploadDir;
        if (userId) {
            // Session auth: get user directory
            db.getUserById(userId, (err, user) => {
                if (err || !user) {
                    // Clean up files if user not found
                    req.files.forEach(file => fs.unlinkSync(file.path));
                    return res.status(404).json({ error: 'User not found' });
                }
                uploadDir = getUserUploadDir(userId, user.user_folder);
            });
        } else {
            // Bearer token auth: use shared directory
            uploadDir = path.join(UPLOAD_BASE_DIR, 'shared');
        }
        
        // Create upload directory if it doesn't exist
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        
        const uploadedFiles = [];
        
        // Process each file
        for (const file of req.files) {
            const fileId = generateUUID();
            const storedName = generateStoredFilename(file.originalname, uploadDir);
            const ext = getFileExtension(file.originalname);
            
            // Final destination path
            const finalPath = path.join(uploadDir, storedName);
            
            // Move file from temp to final location
            fs.renameSync(file.path, finalPath);
            
            // Calculate SHA256 hash if requested
            let sha256 = null;
            if (req.body.calculate_hash === 'true') {
                try {
                    sha256 = await calculateSHA256(finalPath);
                } catch (hashErr) {
                    console.error('Failed to calculate SHA256:', hashErr);
                }
            }
            
            // Insert file record into database
            const fileData = {
                id: fileId,
                bucket: bucket,
                original_name: file.originalname,
                stored_name: storedName,
                size: file.size,
                mime: file.mimetype,
                sha256: sha256,
                uploader_ip: uploaderIp,
                user_id: userId
            };
            
            db.insertFile(fileData, (err) => {
                if (err) {
                    console.error('Failed to insert file record:', err);
                }
            });
            
            uploadedFiles.push({
                id: fileId,
                original_name: file.originalname,
                stored_name: storedName,
                size: file.size,
                mime: file.mimetype,
                sha256: sha256,
                bucket: bucket,
                download_url: `/files/${fileId}`
            });
        }
        
        res.json({
            uploaded: uploadedFiles
        });
        
    } catch (error) {
        console.error('Upload error:', error);
        
        // Clean up any uploaded files
        if (req.files) {
            req.files.forEach(file => {
                if (fs.existsSync(file.path)) {
                    fs.unlinkSync(file.path);
                }
            });
        }
        
        res.status(500).json({ error: 'Upload failed', details: error.message });
    }
});

// Download endpoint (GET /files/{id}) - Project requirement
app.get('/files/:id', (req, res) => {
    const fileId = req.params.id;
    
    // Check auth if required
    if (REQUIRE_AUTH_FOR_DOWNLOAD) {
        const authResult = requireAuthCombined(req, res, () => {});
        if (authResult) return; // Auth failed
    }
    
    // Get file info from database
    db.getFileById(fileId, (err, file) => {
        if (err || !file) {
            return res.status(404).json({ error: 'File not found' });
        }
        
        const filePath = path.join(UPLOAD_BASE_DIR, file.bucket, file.stored_name);
        
        if (!fs.existsSync(filePath)) {
            return res.status(404).json({ error: 'File not found on disk' });
        }
        
        // Set headers for download
        res.setHeader('Content-Disposition', `attachment; filename="${file.original_name}"`);
        res.setHeader('Content-Type', file.mime);
        
        // Send file
        res.sendFile(filePath);
    });
});

// Listing endpoint (GET /files) - Project requirement
app.get('/files', requireAuthCombined, (req, res) => {
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 50, 200); // Max 200
    const q = req.query.q || null;
    const bucket = req.query.bucket || null;
    const from = req.query.from || null;
    const to = req.query.to || null;
    
    const filters = {};
    if (q) filters.q = q;
    if (bucket) filters.bucket = bucket;
    if (from) filters.from = from;
    if (to) filters.to = to;
    
    // If user is logged in via session, filter by their files
    if (req.session.userId) {
        filters.user_id = req.session.userId;
    }
    
    db.getFiles(page, limit, filters, (err, result) => {
        if (err) {
            return res.status(500).json({ error: 'Failed to fetch files' });
        }
        
        res.json({
            page: result.page,
            limit: result.limit,
            total: result.total,
            items: result.items.map(file => ({
                id: file.id,
                original_name: file.original_name,
                size: file.size,
                mime: file.mime,
                bucket: file.bucket,
                created_at: file.created_at
            }))
        });
    });
});

// Delete endpoint (DELETE /files/{id}) - Project requirement
app.delete('/files/:id', requireAuthCombined, (req, res) => {
    if (!ENABLE_DELETE) {
        return res.status(403).json({ error: 'Delete functionality is disabled' });
    }
    
    const fileId = req.params.id;
    
    // Get file info first
    db.getFileById(fileId, (err, file) => {
        if (err || !file) {
            return res.status(404).json({ error: 'File not found' });
        }
        
        // Check permissions: admin token or file owner
        let hasPermission = false;
        
        // Check bearer token (admin)
        if (AUTH_TOKEN && req.headers.authorization) {
            const token = req.headers.authorization.substring(7);
            if (token === AUTH_TOKEN) {
                hasPermission = true;
            }
        }
        
        // Check session user (file owner)
        if (!hasPermission && req.session.userId && file.user_id === req.session.userId) {
            hasPermission = true;
        }
        
        if (!hasPermission) {
            return res.status(403).json({ error: 'Permission denied' });
        }
        
        const filePath = path.join(UPLOAD_BASE_DIR, file.bucket, file.stored_name);
        
        // Delete file from disk
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
        }
        
        // Delete record from database
        db.deleteFile(fileId, (err) => {
            if (err) {
                return res.status(500).json({ error: 'Failed to delete file record' });
            }
            
            res.status(204).send();
        });
    });
});

// Static files (served after routes, before error handler)
app.use(express.static('public'));

// Error handling for file uploads
app.use((err, req, res, next) => {
    if (err instanceof multer.MulterError) {
        // Multer errors
        if (err.code === 'LIMIT_FILE_SIZE') {
            return res.status(413).json({ 
                error: `File too large. Maximum size is ${MAX_FILE_SIZE_MB}MB` 
            });
        }
        if (err.code === 'LIMIT_FILE_COUNT') {
            return res.status(400).json({ 
                error: `Too many files. Maximum is ${MAX_FILES_PER_UPLOAD} files per upload` 
            });
        }
        if (err.code === 'LIMIT_UNEXPECTED_FILE') {
            return res.status(400).json({ 
                error: 'Unexpected file field. Use "files" field for uploads' 
            });
        }
        return res.status(400).json({ error: 'Upload error: ' + err.message });
    }
    
    // Other errors
    if (err.message && err.message.includes('File type not allowed')) {
        return res.status(415).json({ 
            error: 'File type not allowed',
            allowed_extensions: ALLOWED_EXTENSIONS 
        });
    }
    
    console.error('Server error:', err);
    res.status(500).json({ error: 'Internal server error' });
});

// Start server
app.listen(PORT, () => {
    console.log(`ğŸš€ File Upload Server running on port ${PORT}`);
    console.log(`ğŸ“ Upload base directory: ${UPLOAD_BASE_DIR}`);
    console.log(`ğŸ” Login: http://[IP]:${PORT}/login`);
    console.log(`ğŸ‘¤ Default admin: admin/manni`);
    console.log(`ğŸ”§ Project API endpoints:`);
    console.log(`   POST /upload (multipart/form-data)`);
    console.log(`   GET  /files (pagination, filtering)`);
    console.log(`   GET  /files/{id} (download)`);
    console.log(`   DELETE /files/{id} (delete)`);
    console.log(`   GET  /health (health check)`);
    console.log(`ğŸ” Auth: Session (web) OR Bearer Token (API: ${AUTH_TOKEN ? 'SET' : 'NOT SET'})`);
});